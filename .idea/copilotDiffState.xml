<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="from flask import Flask, request, render_template, redirect, url_for&#10;import math&#10;import itertools&#10;&#10;app = Flask(__name__)&#10;&#10;&#10;def calculate_distance(p1, p2):&#10;    &quot;&quot;&quot;Calculates Euclidean distance between two points.&quot;&quot;&quot;&#10;    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)&#10;&#10;&#10;def validate_input(locations_data):&#10;    &quot;&quot;&quot;&#10;    Validates that input is a list of tuples/lists,&#10;    contains only numbers, and has dimension 2.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(locations_data, list):&#10;        return False&#10;    if len(locations_data) == 0:&#10;        return False&#10;    for point in locations_data:&#10;        # Check if point is tuple or list and has exactly 2 coordinates&#10;        if not isinstance(point, (list, tuple)) or len(point) != 2:&#10;            return False&#10;        # Check if coordinates are numbers (int or float)&#10;        if not all(isinstance(coord, (int, float)) for coord in point):&#10;            return False&#10;    return True&#10;&#10;&#10;@app.route('/')&#10;def home():&#10;    # Check if 'locations' parameter exists in URL&#10;    locations_str = request.args.get('locations')&#10;&#10;    # If no locations are provided, render the Home Page&#10;    if locations_str is None:&#10;        return render_template('home_page.html')&#10;&#10;    # If locations ARE provided, process the TSP logic&#10;    try:&#10;        # Parse the input string using eval() as suggested&#10;        # Note: In a production environment, ast.literal_eval is safer,&#10;        # but we are following the assignment hints.&#10;        locations = eval(locations_str)&#10;&#10;        # Validate Input&#10;        if not validate_input(locations):&#10;            raise ValueError(&quot;Invalid input format&quot;)&#10;&#10;        # TSP Logic&#10;        start_node = (0, 0)&#10;        min_distance = float('inf')&#10;        best_path = []&#10;&#10;        # Generate all permutations of the locations&#10;        # We fix the start/end at (0,0), so we permute the destinations&#10;        for perm in itertools.permutations(locations):&#10;            current_path = [start_node] + list(perm) + [start_node]&#10;            current_dist = 0&#10;&#10;            # Calculate total distance for this permutation&#10;            for i in range(len(current_path) - 1):&#10;                current_dist += calculate_distance(current_path[i], current_path[i + 1])&#10;&#10;            # Check if this is the shortest path&#10;            if current_dist &lt; min_distance:&#10;                min_distance = current_dist&#10;                best_path = current_path&#10;&#10;        # Prepare data for the table&#10;        # Steps format: (Index, From, To)&#10;        steps = []&#10;        for i in range(len(best_path) - 1):&#10;            steps.append({&#10;                &quot;id&quot;: i + 1,&#10;                &quot;from&quot;: best_path[i],&#10;                &quot;to&quot;: best_path[i + 1]&#10;            })&#10;&#10;        # Render Results Page&#10;        return render_template(&#10;            'results.html',&#10;            distance=f&quot;{min_distance:.3f}&quot;,&#10;            steps=steps&#10;        )&#10;&#10;    except Exception:&#10;        # In case of any error (parsing or logic), show error message&#10;        return render_template('results.html', error=True)&#10;&#10;&#10;# Handle 404 errors by redirecting to home page&#10;@app.errorhandler(404)&#10;def page_not_found(e):&#10;    return redirect(url_for('home'))&#10;&#10;&#10;if __name__ == '__main__':&#10;    app.run(debug=True)&#10;&#10;" />
              <option name="updatedContent" value="from flask import Flask, request, render_template, redirect, url_for&#10;import math&#10;import itertools&#10;&#10;app = Flask(__name__)&#10;&#10;&#10;def calculate_distance(p1, p2):&#10;    &quot;&quot;&quot;Calculates Euclidean distance between two points.&quot;&quot;&quot;&#10;    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)&#10;&#10;&#10;def validate_input(locations_data):&#10;    &quot;&quot;&quot;&#10;    Validates that input is a list of tuples/lists,&#10;    contains only numbers, and has dimension 2.&#10;    Accepts both positive and negative numbers.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(locations_data, list):&#10;        return False&#10;    if len(locations_data) == 0:&#10;        return False&#10;    for point in locations_data:&#10;        # Check if point is tuple or list and has exactly 2 coordinates&#10;        if not isinstance(point, (list, tuple)) or len(point) != 2:&#10;            return False&#10;        # Check if coordinates are numbers (int or float) - both positive and negative&#10;        if not all(isinstance(coord, (int, float)) and not isinstance(coord, bool) for coord in point):&#10;            return False&#10;    return True&#10;&#10;&#10;@app.route('/')&#10;def home():&#10;    # Check if 'locations' parameter exists in URL&#10;    locations_str = request.args.get('locations')&#10;&#10;    # If no locations are provided, render the Home Page&#10;    if locations_str is None:&#10;        return render_template('home_page.html')&#10;&#10;    # If locations ARE provided, process the TSP logic&#10;    try:&#10;        # Parse the input string using eval() as suggested&#10;        # Note: In a production environment, ast.literal_eval is safer,&#10;        # but we are following the assignment hints.&#10;        locations = eval(locations_str)&#10;&#10;        # Validate Input&#10;        if not validate_input(locations):&#10;            raise ValueError(&quot;Invalid input format&quot;)&#10;&#10;        # ...existing code...&#10;        start_node = (0, 0)&#10;        min_distance = float('inf')&#10;        best_path = []&#10;&#10;        # Generate all permutations of the locations&#10;        # We fix the start/end at (0,0), so we permute the destinations&#10;        for perm in itertools.permutations(locations):&#10;            current_path = [start_node] + list(perm) + [start_node]&#10;            current_dist = 0&#10;&#10;            # Calculate total distance for this permutation&#10;            for i in range(len(current_path) - 1):&#10;                current_dist += calculate_distance(current_path[i], current_path[i + 1])&#10;&#10;            # Check if this is the shortest path&#10;            if current_dist &lt; min_distance:&#10;                min_distance = current_dist&#10;                best_path = current_path&#10;&#10;        # Prepare data for the table&#10;        # Steps format: (Index, From, To)&#10;        steps = []&#10;        for i in range(len(best_path) - 1):&#10;            steps.append({&#10;                &quot;id&quot;: i + 1,&#10;                &quot;from&quot;: best_path[i],&#10;                &quot;to&quot;: best_path[i + 1]&#10;            })&#10;&#10;        # Render Results Page&#10;        return render_template(&#10;            'results.html',&#10;            distance=f&quot;{min_distance:.3f}&quot;,&#10;            steps=steps&#10;        )&#10;&#10;    except Exception:&#10;        # In case of any error (parsing or logic), show error message&#10;        return render_template('results.html', error=True)&#10;&#10;&#10;# Handle 404 errors by redirecting to home page&#10;@app.errorhandler(404)&#10;def page_not_found(e):&#10;    return redirect(url_for('home'))&#10;&#10;&#10;if __name__ == '__main__':&#10;    app.run(debug=True)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_tsp_expected.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_tsp_expected.py" />
              <option name="updatedContent" value="#!/usr/bin/env python&#10;&quot;&quot;&quot;Test TSP calculation with the expected example&quot;&quot;&quot;&#10;&#10;import math&#10;import itertools&#10;&#10;def calculate_distance(p1, p2):&#10;    &quot;&quot;&quot;Calculates Euclidean distance between two points.&quot;&quot;&quot;&#10;    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)&#10;&#10;def solve_tsp(locations):&#10;    &quot;&quot;&quot;Solve TSP problem&quot;&quot;&quot;&#10;    start_node = (0, 0)&#10;    min_distance = float('inf')&#10;    best_path = []&#10;    &#10;    for perm in itertools.permutations(locations):&#10;        current_path = [start_node] + list(perm) + [start_node]&#10;        current_dist = 0&#10;        &#10;        for i in range(len(current_path) - 1):&#10;            current_dist += calculate_distance(current_path[i], current_path[i + 1])&#10;        &#10;        if current_dist &lt; min_distance:&#10;            min_distance = current_dist&#10;            best_path = current_path&#10;    &#10;    return best_path, min_distance&#10;&#10;# Test with the example from the assignment&#10;locations = [(1, 1), (-1, -1), (2, 3)]&#10;path, distance = solve_tsp(locations)&#10;&#10;print(f&quot;Input locations: {locations}&quot;)&#10;print(f&quot;Shortest path: {path}&quot;)&#10;print(f&quot;Distance: {distance:.3f}&quot;)&#10;print(f&quot;Expected: 10.064&quot;)&#10;print(f&quot;Match: {abs(distance - 10.064) &lt; 0.001}&quot;)&#10;print(&quot;\nPath breakdown:&quot;)&#10;for i in range(len(path) - 1):&#10;    d = calculate_distance(path[i], path[i + 1])&#10;    print(f&quot;  {i+1}. {path[i]} -&gt; {path[i+1]}: {d:.3f}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_validation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_validation.py" />
              <option name="updatedContent" value="#!/usr/bin/env python&#10;&quot;&quot;&quot;Test validation with negative numbers&quot;&quot;&quot;&#10;&#10;def validate_input(locations_data):&#10;    &quot;&quot;&quot;&#10;    Validates that input is a list of tuples/lists,&#10;    contains only numbers, and has dimension 2.&#10;    Accepts both positive and negative numbers.&#10;    &quot;&quot;&quot;&#10;    if not isinstance(locations_data, list):&#10;        return False&#10;    if len(locations_data) == 0:&#10;        return False&#10;    for point in locations_data:&#10;        # Check if point is tuple or list and has exactly 2 coordinates&#10;        if not isinstance(point, (list, tuple)) or len(point) != 2:&#10;            return False&#10;        # Check if coordinates are numbers (int or float) - both positive and negative&#10;        if not all(isinstance(coord, (int, float)) and not isinstance(coord, bool) for coord in point):&#10;            return False&#10;    return True&#10;&#10;# Test cases&#10;test_cases = [&#10;    ([(1, 1), (-1, -1), (2, 3)], True, &quot;Mixed positive and negative&quot;),&#10;    ([(0, 0)], True, &quot;Single point at origin&quot;),&#10;    ([(1.5, -2.5)], True, &quot;Float coordinates&quot;),&#10;    ([], False, &quot;Empty list&quot;),&#10;    ([(1, 2, 3)], False, &quot;3D point&quot;),&#10;    ([(1, &quot;a&quot;)], False, &quot;Non-numeric coordinate&quot;),&#10;]&#10;&#10;for test_input, expected, description in test_cases:&#10;    result = validate_input(test_input)&#10;    status = &quot;✓&quot; if result == expected else &quot;✗&quot;&#10;    print(f&quot;{status} {description}: {test_input} -&gt; {result} (expected {expected})&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>